// Generated by LiveScript 1.6.0
(function(){
  var join$ = [].join, slice$ = [].slice;
  (function(){
    var ref$, fail, exit, actualScriptName, resultOrError, ifThenElse, map, type, isObject, isFunction, valueAsString, kebabCase, objectMemberPairs, keep, valueTypeName, stdout, linesAsString, fatalError, COMMAND_NOT_RECOGNIZED, descriptionOrHint, descriptionHint, functionDescriptionAndHint, functionUsage, commandDescription, subcommandsUsage, objectUsage, commandUsage, showCommandUsage, isValidCommandNode, validateCommands, injectHelpCommands, resultAsErrorlevel, executeSelectedCommand, selectCommand, executeCommand;
    ref$ = dependency('os.shell.Script'), fail = ref$.fail, exit = ref$.exit, actualScriptName = ref$.scriptName;
    ref$ = dependency('flow.Conditional'), resultOrError = ref$.resultOrError, ifThenElse = ref$.ifThenElse;
    map = dependency('unsafe.Array').mapArrayItems;
    type = dependency('reflection.Type').type;
    isObject = dependency('unsafe.Object').isObject;
    isFunction = dependency('unsafe.Function').isFunction;
    valueAsString = dependency('reflection.Value').valueAsString;
    kebabCase = dependency('unsafe.StringCase').kebabCase;
    objectMemberPairs = dependency('unsafe.Object').objectMemberPairs;
    keep = dependency('unsafe.Array').keepArrayItems;
    valueTypeName = dependency('reflection.TypeName').valueTypeName;
    stdout = dependency('os.shell.IO').stdout;
    linesAsString = dependency('unsafe.Text').linesAsString;
    fatalError = function(messageLines, errorlevel){
      fail(['Fatal Error:'].concat(messageLines), errorlevel);
    };
    COMMAND_NOT_RECOGNIZED = 9009;
    descriptionOrHint = function(comment, index){
      switch (index) {
      case 0:
        return comment;
      case 1:
        return "  " + comment;
      }
    };
    descriptionHint = function(arg$){
      var description, hint;
      description = arg$[0], hint = arg$[1];
      return {
        description: description,
        hint: hint
      };
    };
    functionDescriptionAndHint = function(it){
      return descriptionHint(
      map(functionComments(
      it), descriptionOrHint));
    };
    functionUsage = function(commandFunction, commandPath){
      var paramNames, usage, ref$, description, hint, options;
      paramNames = functionParameterNames(commandFunction);
      usage = map(paramNames, function(it){
        return function(it){
          return ["Usage: " + join$.call(commandPath, ' ') + " " + join$.call(it, ' ')];
        }(
        "[" + asOption(it) + "]");
      });
      ref$ = functionDescriptionAndHint(commandFunction), description = ref$.description, hint = ref$.hint;
      options = map(_(function(it){
        return function(it){
          if (arraySize(it) === 0) {
            return it;
          }
          return ["Options: "].concat(it);
        }(
        "  " + asOption(it));
      }))(
      paramNames);
      return usage.concat(description, hint, options);
    };
    commandDescription = function(arg$){
      var commandName, command, description;
      commandName = arg$[0], command = arg$[1];
      description = (function(){
        switch (typeof command) {
        case 'function':
          return function(it){
            return it.description;
          }(
          functionDescriptionAndHint(
          command));
        case 'object':
          return '[sub-command...]';
        }
      }());
      return "  " + kebabCase(commandName) + " " + description;
    };
    subcommandsUsage = function(command){
      return keep(objectMemberPairs(
      command), function(arg$){
        var name;
        name = arg$[0];
        return map(name !== 'help', commandDescription);
      });
    };
    objectUsage = function(command, commandPath){
      var usage, subcommands;
      usage = ["Usage: " + join$.call(commandPath, ' ') + " <command> [options...]", ""];
      subcommands = subcommandsUsage(command);
      return usage.concat(["Available commands for " + join$.call(commandPath, ' ') + ":"], subcommands);
    };
    commandUsage = function(commandPathNode, commandPath){
      switch (typeof commandPathNode) {
      case 'function':
        return functionUsage(commandPathNode, commandPath);
      case 'object':
        return objectUsage(commandPathNode, commandPath);
      }
    };
    showCommandUsage = function(command, commandPath){
      stdout(
      linesAsString(
      commandUsage(command, commandPath)));
      return 0;
    };
    isValidCommandNode = function(node){
      return isObject(node) || isFunction(node);
    };
    validateCommands = function(commandNode, commandPath){
      var key, value, results$ = [];
      if (!isValidCommandNode(commandNode)) {
        fatalError(["Invalid command value at path: '" + join$.call(commandPath, ' ') + "'", "Command must be either function or object, but found " + valueTypeName(commandNode)], COMMAND_NOT_RECOGNIZED);
      }
      if (isObject(commandNode)) {
        for (key in commandNode) {
          value = commandNode[key];
          results$.push(validateCommands(value, commandPath.concat([kebabCase(key)])));
        }
        return results$;
      }
    };
    injectHelpCommands = function(commands, scriptName){
      var walk;
      scriptName == null && (scriptName = actualScriptName);
      walk = function(node, path){
        var key, value;
        type('< Object Function >', node);
        if (isFunction(node)) {
          return;
        }
        if (!isObject(node, scriptName)) {
          invalidCommandValue(node, path);
        }
        for (key in node) {
          value = node[key];
          if (value(isObject(value))) {
            walk(value, path.concat([kebabCase(key)]));
          }
        }
        node.help = showCommandUsage(node, path);
      };
      walk(commands, [scriptName]);
      return commands;
    };
    resultAsErrorlevel = function(result){
      if (typeof result === 'number') {
        return result;
      } else {
        return 0;
      }
    };
    executeSelectedCommand = function(it){
      var x$, ref$, commandFn, commandArgs, commandPath;
      type('{ result:Object|Null error:Object|Null }', it);
      x$ = it.error;
      if (x$ != null) {
        fail([x$.message], 9009);
      }
      ref$ = it.result, commandFn = ref$.commandFn, commandArgs = ref$.commandArgs, commandPath = ref$.commandPath;
      return function(arg$){
        var success, result, error;
        success = arg$.success, result = arg$.result, error = arg$.error;
        switch (success) {
        case true:
          return exit(resultAsErrorlevel(result));
        case false:
          return fail(fatalErrorMessage(commandPath, error), 1);
        }
      }(
      resultOrError(
      function(){
        return commandFn.apply(null, commandArgs);
      }));
    };
    selectCommand = function(commands, argv){
      var ref$, commandPathNode, commandPath, args, parsedArgs, commandArgs, suggestions, message;
      ref$ = findCommandPathNode(argv, commands), commandPathNode = ref$.commandPathNode, commandPath = ref$.commandPath, args = ref$.args;
      switch (typeof commandPathNode) {
      case 'function':
        parsedArgs = parseArgs(args);
        commandArgs = map(partialize$.apply(this, [
          compose$, [
            function(it){
              return parsedArgs[it];
            }, void 8
          ], [1]
        ]))(
        functionParameterNames(
        commandPathNode));
        return {
          success: true,
          result: {
            commandPath: commandPath,
            commandFn: commandPathNode,
            commandArgs: commandArgs
          }
        };
      case 'object':
        suggestions = map(objectKeys(
        commandPathNode), kebabCase);
        message = linesAsString(
        [("Incomplete command: '" + join$.call(commandPath, ' ') + "'")["Did you mean one of: " + join$.call(suggestions, ', ')]]);
        return {
          success: false,
          error: {
            message: message
          }
        };
      }
    };
    executeCommand = function(commands, argv, scriptName, pipelineInterceptor){
      var interceptor;
      type('< Object >', commands);
      type('[ *:String ]', argv);
      type('< String Undefined >', scriptName);
      type('< Function Undefined >', pipelineInterceptor);
      interceptor = pipelineInterceptor !== void 8
        ? pipelineInterceptor
        : function(it){
          return it;
        };
      return executeSelectedCommand(
      interceptor(
      selectCommand(injectHelpCommands(validateCommands(commands, [scriptName]), scriptName), argv)));
    };
    return {
      executeCommand: executeCommand
    };
  })();
  function compose$() {
    var functions = arguments;
    return function() {
      var i, result;
      result = functions[0].apply(this, arguments);
      for (i = 1; i < functions.length; ++i) {
        result = functions[i](result);
      }
      return result;
    };
  }
  function partialize$(f, args, where){
    var context = this;
    return function(){
      var params = slice$.call(arguments), i,
          len = params.length, wlen = where.length,
          ta = args ? args.concat() : [], tw = where ? where.concat() : [];
      for(i = 0; i < len; ++i) { ta[tw[0]] = params[i]; tw.shift(); }
      return len < wlen && len ?
        partialize$.apply(context, [f, ta, tw]) : f.apply(context, ta);
    };
  }
}).call(this);
